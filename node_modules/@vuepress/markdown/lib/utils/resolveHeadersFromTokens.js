"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveHeadersFromTokens = void 0;
const shared_1 = require("@vuepress/shared");
const resolveTitleFromToken_1 = require("./resolveTitleFromToken");
/**
 * Resolve headers from markdown-it tokens
 */
const resolveHeadersFromTokens = (tokens, { level, allowHtml, escapeText, slugify, format, }) => {
    // store the result of headers
    const headers = [];
    // a temp headers stack for generating the headers tree
    const stack = [];
    // push a header to the headers tree
    const push = (header) => {
        while (stack.length !== 0 && header.level <= stack[0].level) {
            stack.shift();
        }
        if (stack.length === 0) {
            headers.push(header);
            stack.push(header);
        }
        else {
            stack[0].children.push(header);
            stack.unshift(header);
        }
    };
    tokens.forEach((_, idx) => {
        var _a;
        const token = tokens[idx];
        // if the token type does not match, skip
        if ((token === null || token === void 0 ? void 0 : token.type) !== 'heading_open') {
            return;
        }
        // get the level from the tag, h1 -> 1
        const headerLevel = Number.parseInt(token.tag.slice(1), 10);
        // if the level should not be extracted, skip
        if (!level.includes(headerLevel)) {
            return;
        }
        // the next token of 'heading_open' contains the heading content
        const nextToken = tokens[idx + 1];
        // if the next token does not exist, skip
        if (!nextToken) {
            return;
        }
        const title = (0, resolveTitleFromToken_1.resolveTitleFromToken)(nextToken, {
            allowHtml,
            escapeText,
        });
        // the id of the heading anchor is the slugify result of markdown-it-anchor
        // if the id does not exist, slugify the title ourselves
        const slug = (_a = token.attrGet('id')) !== null && _a !== void 0 ? _a : slugify(title);
        // push the header to tree
        push({
            level: headerLevel,
            title: (0, shared_1.isFunction)(format) ? format(title) : title,
            slug,
            children: [],
        });
    });
    return headers;
};
exports.resolveHeadersFromTokens = resolveHeadersFromTokens;
